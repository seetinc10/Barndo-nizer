<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Blueprint Floor Plan Generator</title>
  <link href="https://cdn.replit.com/agent/bootstrap-agent-dark-theme.min.css" rel="stylesheet">
  <style>
    canvas {
      background: var(--bs-dark);
      border: 1px solid var(--bs-border-color);
      max-width: 100%;
      height: auto;
    }

    .dimension-input {
      width: 80px;
    }
  </style>
</head>
<body>
  <div class="container py-4">
    <h2 class="text-center mb-4">Blueprint Floor Plan Generator</h2>

    <!-- Dimension inputs -->
    <div class="row justify-content-center mb-4">
      <div class="col-12 col-md-6">
        <div class="card bg-dark">
          <div class="card-body">
            <form id="dimensionsForm" class="row g-3">
              <!-- Length inputs -->
              <div class="col-12">
                <label class="form-label">Length:</label>
                <div class="d-flex gap-2 align-items-center">
                  <input type="number" id="lengthFeet" class="form-control dimension-input" min="1" max="100" value="20">
                  <label>feet</label>
                  <input type="number" id="lengthInches" class="form-control dimension-input" min="0" max="11" value="0">
                  <label>inches</label>
                </div>
              </div>

              <!-- Width inputs -->
              <div class="col-12">
                <label class="form-label">Width:</label>
                <div class="d-flex gap-2 align-items-center">
                  <input type="number" id="widthFeet" class="form-control dimension-input" min="1" max="100" value="15">
                  <label>feet</label>
                  <input type="number" id="widthInches" class="form-control dimension-input" min="0" max="11" value="0">
                  <label>inches</label>
                </div>
              </div>

              <div class="col-12">
                <button type="submit" class="btn btn-primary w-100">Update Dimensions</button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>

    <!-- Canvas container -->
    <div class="text-center mb-3">
      <canvas id="floorplan" width="800" height="600"></canvas>
    </div>

    <div class="text-center">
      <div class="btn-group mb-3">
        <button id="generateBtn" class="btn btn-secondary">Generate New Layout</button>
        <button id="exportPNGBtn" class="btn btn-primary">Export as PNG</button>
        <button id="exportPDFBtn" class="btn btn-primary">Export as PDF</button>
      </div>
    </div>
  </div>

  <!-- Include jsPDF library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    // Get canvas context and form elements
    const canvas = document.getElementById('floorplan');
    const ctx = canvas.getContext('2d');
    const generateBtn = document.getElementById('generateBtn');
    const dimensionsForm = document.getElementById('dimensionsForm');

    // Constants
    const MIN_ROOM_SIZE = 80;
    const PARTITION_DEPTH = 3;
    const PIXELS_PER_FOOT = 20; // Scale factor for converting feet to pixels

    // Constants for room types and sizes (in square feet)
    const ROOM_STANDARDS = {
      'Living Room': { minArea: 280, idealArea: 320, minWidth: 14 },
      'Master Bedroom': { minArea: 200, idealArea: 224, minWidth: 12 },
      'Kitchen': { minArea: 160, idealArea: 180, minWidth: 10 },
      'Bedroom': { minArea: 120, idealArea: 144, minWidth: 10 },
      'Bathroom': { minArea: 35, idealArea: 40, minWidth: 5 },
      'Laundry Room': { minArea: 42, idealArea: 48, minWidth: 6 }
    };

    const ROOM_TYPES = Object.keys(ROOM_STANDARDS);

    // Data structure for each partition/room
    class Node {
      constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.left = null;
        this.right = null;
        this.door = null;
        this.roomType = null;
      }

      isLeaf() {
        return this.left === null && this.right === null;
      }

      getArea() {
        return this.w * this.h / (PIXELS_PER_FOOT * PIXELS_PER_FOOT);
      }

      getWidth() {
        return this.w / PIXELS_PER_FOOT;
      }
    }

    let roomLeaves = [];
    let doors = [];

    // Convert feet and inches to pixels
    function dimensionsToPixels(feet, inches) {
      return Math.round((feet + inches/12) * PIXELS_PER_FOOT);
    }

    // Convert pixels to feet and inches
    function pixelsToFeetAndInches(pixels) {
      const totalFeet = pixels / PIXELS_PER_FOOT;
      const feet = Math.floor(totalFeet);
      const inches = Math.round((totalFeet - feet) * 12);
      return `${feet}'${inches}"`;
    }

    function partition(node, depth) {
      if (depth <= 0) {
        roomLeaves.push(node);
        return;
      }

      // Calculate minimum sizes based on room standards
      const minArea = Math.min(...Object.values(ROOM_STANDARDS).map(s => s.minArea));
      const minWidth = Math.min(...Object.values(ROOM_STANDARDS).map(s => s.minWidth));
      const minPixels = minWidth * PIXELS_PER_FOOT;

      if (node.w < minPixels * 2 || node.h < minPixels * 2) {
        roomLeaves.push(node);
        return;
      }

      let splitVertically;
      if (node.w / node.h >= 1.25) {
        splitVertically = true;
      } else if (node.h / node.w >= 1.25) {
        splitVertically = false;
      } else {
        splitVertically = Math.random() > 0.5;
      }

      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      if (splitVertically && node.w >= minPixels * 2) {
        // Ensure minimum width for both resulting rooms
        const minSplit = node.x + minPixels;
        const maxSplit = node.x + node.w - minPixels;
        const splitX = randomInt(minSplit, maxSplit);

        node.left = new Node(node.x, node.y, splitX - node.x, node.h);
        node.right = new Node(splitX, node.y, node.x + node.w - splitX, node.h);

        const doorY = randomInt(node.y + 20, node.y + node.h - 20);
        node.door = {
          orientation: 'vertical',
          x: splitX,
          y: doorY,
          length: 30
        };
        doors.push(node.door);
      } else if (!splitVertically && node.h >= minPixels * 2) {
        const minSplit = node.y + minPixels;
        const maxSplit = node.y + node.h - minPixels;
        const splitY = randomInt(minSplit, maxSplit);

        node.left = new Node(node.x, node.y, node.w, splitY - node.y);
        node.right = new Node(node.x, splitY, node.w, node.y + node.h - splitY);

        const doorX = randomInt(node.x + 20, node.x + node.w - 20);
        node.door = {
          orientation: 'horizontal',
          x: doorX,
          y: splitY,
          length: 30
        };
        doors.push(node.door);
      } else {
        roomLeaves.push(node);
        return;
      }

      partition(node.left, depth - 1);
      partition(node.right, depth - 1);
    }

    // Function to assign room types based on residential standards
    function assignRoomTypes() {
      // Sort rooms by size (largest to smallest)
      const sortedRooms = [...roomLeaves].sort((a, b) => b.getArea() - a.getArea());
      let remainingRooms = [...ROOM_TYPES];

      // First pass: assign rooms that meet ideal size requirements
      sortedRooms.forEach(room => {
        const area = room.getArea();
        const width = room.getWidth();

        // Try to match room with ideal specifications
        for (let i = 0; i < remainingRooms.length; i++) {
          const roomType = remainingRooms[i];
          const standard = ROOM_STANDARDS[roomType];

          if (area >= standard.minArea && width >= standard.minWidth) {
            room.roomType = roomType;
            remainingRooms.splice(i, 1);
            break;
          }
        }
      });

      // Second pass: assign any remaining rooms
      sortedRooms.forEach(room => {
        if (!room.roomType) {
          if (remainingRooms.length > 0) {
            // Assign the best remaining room type
            room.roomType = remainingRooms.shift();
          } else {
            // Default to bedroom for any unassigned rooms
            room.roomType = 'Bedroom';
          }
        }
      });
    }

    function drawBlueprint() {
      ctx.fillStyle = '#2d3e50';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.lineCap = 'butt';

      roomLeaves.forEach(room => {
        ctx.strokeRect(room.x, room.y, room.w, room.h);

        // Display room dimensions and type
        const roomWidthText = pixelsToFeetAndInches(room.w);
        const roomHeightText = pixelsToFeetAndInches(room.h);

        ctx.font = '14px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        // Room type on top
        ctx.fillText(room.roomType || 'Room',
                    room.x + room.w / 2,
                    room.y + room.h / 2 - 10);

        // Dimensions below
        ctx.fillText(`${roomWidthText} Ã— ${roomHeightText}`,
                    room.x + room.w / 2,
                    room.y + room.h / 2 + 10);
      });

      // Draw doors
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 4;
      doors.forEach(door => {
        if (door.orientation === 'vertical') {
          ctx.beginPath();
          ctx.moveTo(door.x, door.y - door.length / 2);
          ctx.lineTo(door.x, door.y + door.length / 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(door.x, door.y - door.length / 2,
                 door.length / 2, Math.PI, Math.PI * 1.5, false);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(door.x - door.length / 2, door.y);
          ctx.lineTo(door.x + door.length / 2, door.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(door.x + door.length / 2, door.y,
                 door.length / 2, Math.PI, Math.PI * 1.5, true);
          ctx.stroke();
        }
      });

      drawWindows();
    }

    function drawWindows() {
      ctx.strokeStyle = '#00aaff';
      ctx.lineWidth = 3;
      const winLen = 40;

      // Draw windows on all four sides
      [
        {start: [50, 10], end: [canvas.width - 50, 10], clear: (x) => ctx.clearRect(x, 0, winLen, 5)},
        {start: [50, canvas.height - 10], end: [canvas.width - 50, canvas.height - 10], 
         clear: (x) => ctx.clearRect(x, canvas.height - 5, winLen, 5)},
        {start: [10, 50], end: [10, canvas.height - 50], 
         clear: (y) => ctx.clearRect(0, y, 5, winLen)},
        {start: [canvas.width - 10, 50], end: [canvas.width - 10, canvas.height - 50], 
         clear: (y) => ctx.clearRect(canvas.width - 5, y, 5, winLen)}
      ].forEach(wall => {
        ctx.beginPath();
        ctx.moveTo(...wall.start);
        ctx.lineTo(...wall.end);
        ctx.stroke();

        const isVertical = wall.start[0] === wall.end[0];
        const start = isVertical ? 60 : 60;
        const end = isVertical ? canvas.height - 50 : canvas.width - 50;

        for (let pos = start; pos < end; pos += winLen + 20) {
          wall.clear(pos);
        }
      });
    }

    function generateFloorPlan() {
      roomLeaves = [];
      doors = [];

      const lengthFeet = parseInt(document.getElementById('lengthFeet').value) || 20;
      const lengthInches = parseInt(document.getElementById('lengthInches').value) || 0;
      const widthFeet = parseInt(document.getElementById('widthFeet').value) || 15;
      const widthInches = parseInt(document.getElementById('widthInches').value) || 0;

      const pixelWidth = dimensionsToPixels(lengthFeet, lengthInches);
      const pixelHeight = dimensionsToPixels(widthFeet, widthInches);

      // Update canvas size while maintaining aspect ratio
      const maxWidth = 800;
      const scale = Math.min(1, maxWidth / pixelWidth);

      canvas.width = pixelWidth * scale;
      canvas.height = pixelHeight * scale;

      const margin = 50;
      const mainArea = new Node(
        margin,
        margin,
        canvas.width - margin * 2,
        canvas.height - margin * 2
      );

      partition(mainArea, PARTITION_DEPTH);
      assignRoomTypes();
      drawBlueprint();
    }

    // Export functions
    function exportAsPNG() {
      const link = document.createElement('a');
      link.download = 'floor-plan.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function exportAsPDF() {
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({
        orientation: 'landscape',
        unit: 'px',
        format: [canvas.width, canvas.height]
      });

      // Add the canvas image to the PDF
      const imgData = canvas.toDataURL('image/png');
      pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);

      // Save the PDF
      pdf.save('floor-plan.pdf');
    }

    // Add export button event listeners
    document.getElementById('exportPNGBtn').addEventListener('click', exportAsPNG);
    document.getElementById('exportPDFBtn').addEventListener('click', exportAsPDF);

    // Event Listeners
    dimensionsForm.addEventListener('submit', (e) => {
      e.preventDefault();
      generateFloorPlan();
    });

    generateBtn.addEventListener('click', generateFloorPlan);

    // Initial generation
    generateFloorPlan();
  </script>
</body>
</html>