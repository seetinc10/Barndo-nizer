<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Barndo Floor Plan Generator</title>
  <link href="https://cdn.replit.com/agent/bootstrap-agent-dark-theme.min.css" rel="stylesheet">
  <style>
    canvas {
      background: var(--bs-dark);
      border: 1px solid var(--bs-border-color);
      max-width: 100%;
      height: auto;
    }

    .dimension-input {
      width: 80px;
    }
  </style>
</head>
<body>
  <div class="container py-4">
    <h2 class="text-center mb-4">Barndo Floor Plan Generator</h2>

    <!-- Dimension inputs -->
    <div class="row justify-content-center mb-4">
      <div class="col-12 col-md-6">
        <div class="card bg-dark">
          <div class="card-body">
            <form id="dimensionsForm" class="row g-3">
              <!-- Length inputs -->
              <div class="col-12">
                <label class="form-label">Length:</label>
                <div class="d-flex gap-2 align-items-center">
                  <input type="number" id="lengthFeet" class="form-control dimension-input" min="1" max="100" value="30">
                  <label>feet</label>
                  <input type="number" id="lengthInches" class="form-control dimension-input" min="0" max="11" value="0">
                  <label>inches</label>
                </div>
              </div>

              <!-- Width inputs -->
              <div class="col-12">
                <label class="form-label">Width:</label>
                <div class="d-flex gap-2 align-items-center">
                  <input type="number" id="widthFeet" class="form-control dimension-input" min="1" max="100" value="20">
                  <label>feet</label>
                  <input type="number" id="widthInches" class="form-control dimension-input" min="0" max="11" value="0">
                  <label>inches</label>
                </div>
              </div>

              <div class="col-12">
                <button type="submit" class="btn btn-primary w-100">Update Dimensions</button>
              </div>
            </form>
          </div>
        </div>
      </div>
    </div>

    <!-- Canvas container -->
    <div class="text-center mb-3">
      <canvas id="floorplan" width="800" height="600"></canvas>
    </div>

    <div class="text-center">
      <div class="btn-group mb-3">
        <button id="generateBtn" class="btn btn-secondary">Generate New Layout</button>
        <button id="exportPNGBtn" class="btn btn-primary">Export as PNG</button>
        <button id="exportPDFBtn" class="btn btn-primary">Export as PDF</button>
      </div>
    </div>
  </div>

  <!-- Include jsPDF library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <script>
    // Get canvas context and form elements
    const canvas = document.getElementById('floorplan');
    const ctx = canvas.getContext('2d');
    const generateBtn = document.getElementById('generateBtn');
    const dimensionsForm = document.getElementById('dimensionsForm');

    // Constants
    const MIN_ROOM_SIZE = 80;
    const PARTITION_DEPTH = 3;
    const PIXELS_PER_FOOT = 20; // Scale factor for converting feet to pixels

    // Data structure for each partition/room
    class Node {
      constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.left = null;
        this.right = null;
        this.door = null;
      }

      isLeaf() {
        return this.left === null && this.right === null;
      }
    }

    let roomLeaves = [];
    let doors = [];

    // Convert feet and inches to pixels
    function dimensionsToPixels(feet, inches) {
      return Math.round((feet + inches/12) * PIXELS_PER_FOOT);
    }

    // Convert pixels to feet and inches
    function pixelsToFeetAndInches(pixels) {
      const totalFeet = pixels / PIXELS_PER_FOOT;
      const feet = Math.floor(totalFeet);
      const inches = Math.round((totalFeet - feet) * 12);
      return `${feet}'${inches}"`;
    }

    function partition(node, depth) {
      if (depth <= 0 || (node.w < MIN_ROOM_SIZE * 2 && node.h < MIN_ROOM_SIZE * 2)) {
        roomLeaves.push(node);
        return;
      }

      let splitVertically;
      if (node.w / node.h >= 1.25) {
        splitVertically = true;
      } else if (node.h / node.w >= 1.25) {
        splitVertically = false;
      } else {
        splitVertically = Math.random() > 0.5;
      }

      function randomInt(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      if (splitVertically && node.w >= MIN_ROOM_SIZE * 2) {
        const splitX = randomInt(node.x + MIN_ROOM_SIZE, node.x + node.w - MIN_ROOM_SIZE);
        node.left = new Node(node.x, node.y, splitX - node.x, node.h);
        node.right = new Node(splitX, node.y, node.x + node.w - splitX, node.h);

        const doorY = randomInt(node.y + 20, node.y + node.h - 20);
        node.door = {
          orientation: 'vertical',
          x: splitX,
          y: doorY,
          length: 30
        };
        doors.push(node.door);
      } else if (!splitVertically && node.h >= MIN_ROOM_SIZE * 2) {
        const splitY = randomInt(node.y + MIN_ROOM_SIZE, node.y + node.h - MIN_ROOM_SIZE);
        node.left = new Node(node.x, node.y, node.w, splitY - node.y);
        node.right = new Node(node.x, splitY, node.w, node.y + node.h - splitY);

        const doorX = randomInt(node.x + 20, node.x + node.w - 20);
        node.door = {
          orientation: 'horizontal',
          x: doorX,
          y: splitY,
          length: 30
        };
        doors.push(node.door);
      } else {
        roomLeaves.push(node);
        return;
      }

      partition(node.left, depth - 1);
      partition(node.right, depth - 1);
    }

    function drawBlueprint() {
      ctx.fillStyle = '#2d3e50';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.lineCap = 'butt';

      roomLeaves.forEach(room => {
        ctx.strokeRect(room.x, room.y, room.w, room.h);

        // Display room dimensions
        const roomWidthText = pixelsToFeetAndInches(room.w);
        const roomHeightText = pixelsToFeetAndInches(room.h);

        ctx.font = '14px Arial';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(`${roomWidthText} Ã— ${roomHeightText}`,
                    room.x + room.w / 2,
                    room.y + room.h / 2);
      });

      // Draw doors
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 4;
      doors.forEach(door => {
        if (door.orientation === 'vertical') {
          ctx.beginPath();
          ctx.moveTo(door.x, door.y - door.length / 2);
          ctx.lineTo(door.x, door.y + door.length / 2);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(door.x, door.y - door.length / 2,
                 door.length / 2, Math.PI, Math.PI * 1.5, false);
          ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.moveTo(door.x - door.length / 2, door.y);
          ctx.lineTo(door.x + door.length / 2, door.y);
          ctx.stroke();
          ctx.beginPath();
          ctx.arc(door.x + door.length / 2, door.y,
                 door.length / 2, Math.PI, Math.PI * 1.5, true);
          ctx.stroke();
        }
      });

      drawWindows();
    }

    function drawWindows() {
      ctx.strokeStyle = '#00aaff';
      ctx.lineWidth = 3;
      const winLen = 40;

      // Draw windows on all four sides
      [
        {start: [50, 10], end: [canvas.width - 50, 10], clear: (x) => ctx.clearRect(x, 0, winLen, 5)},
        {start: [50, canvas.height - 10], end: [canvas.width - 50, canvas.height - 10], 
         clear: (x) => ctx.clearRect(x, canvas.height - 5, winLen, 5)},
        {start: [10, 50], end: [10, canvas.height - 50], 
         clear: (y) => ctx.clearRect(0, y, 5, winLen)},
        {start: [canvas.width - 10, 50], end: [canvas.width - 10, canvas.height - 50], 
         clear: (y) => ctx.clearRect(canvas.width - 5, y, 5, winLen)}
      ].forEach(wall => {
        ctx.beginPath();
        ctx.moveTo(...wall.start);
        ctx.lineTo(...wall.end);
        ctx.stroke();

        const isVertical = wall.start[0] === wall.end[0];
        const start = isVertical ? 60 : 60;
        const end = isVertical ? canvas.height - 50 : canvas.width - 50;

        for (let pos = start; pos < end; pos += winLen + 20) {
          wall.clear(pos);
        }
      });
    }

    function generateFloorPlan() {
      roomLeaves = [];
      doors = [];

      const lengthFeet = parseInt(document.getElementById('lengthFeet').value) || 20;
      const lengthInches = parseInt(document.getElementById('lengthInches').value) || 0;
      const widthFeet = parseInt(document.getElementById('widthFeet').value) || 15;
      const widthInches = parseInt(document.getElementById('widthInches').value) || 0;

      const pixelWidth = dimensionsToPixels(lengthFeet, lengthInches);
      const pixelHeight = dimensionsToPixels(widthFeet, widthInches);

      // Update canvas size while maintaining aspect ratio
      const maxWidth = 800;
      const scale = Math.min(1, maxWidth / pixelWidth);

      canvas.width = pixelWidth * scale;
      canvas.height = pixelHeight * scale;

      const margin = 50;
      const mainArea = new Node(
        margin,
        margin,
        canvas.width - margin * 2,
        canvas.height - margin * 2
      );

      partition(mainArea, PARTITION_DEPTH);
      drawBlueprint();
    }

    // Export functions
    function exportAsPNG() {
      const link = document.createElement('a');
      link.download = 'floor-plan.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function exportAsPDF() {
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({
        orientation: 'landscape',
        unit: 'px',
        format: [canvas.width, canvas.height]
      });

      // Add the canvas image to the PDF
      const imgData = canvas.toDataURL('image/png');
      pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);

      // Save the PDF
      pdf.save('floor-plan.pdf');
    }

    // Add export button event listeners
    document.getElementById('exportPNGBtn').addEventListener('click', exportAsPNG);
    document.getElementById('exportPDFBtn').addEventListener('click', exportAsPDF);

    // Event Listeners
    dimensionsForm.addEventListener('submit', (e) => {
      e.preventDefault();
      generateFloorPlan();
    });

    generateBtn.addEventListener('click', generateFloorPlan);

    // Initial generation
    generateFloorPlan();
  </script>
</body>
</html>